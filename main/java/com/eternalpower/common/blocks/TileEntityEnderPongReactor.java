package com.eternalpower.common.blocks;

import java.util.LinkedList;
import java.util.ListIterator;

import com.eternalpower.EternalPower;
import com.eternalpower.util.EnderPongPacket;
import com.eternalpower.util.LargeContainer;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tileentity.*;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;



/*
 * The Ender-Pong Reactor is a low-mid power source to end-game power source in which
 * 	The power generated is based off of the number of parameters given.
 * 
 * The essence of the reactor is that power is generated by Enderman simply play pong with you
 * 	form the End, in which you gain Watts (RF/t) from the difference of the push and pull from The End.
 * The whole idea is that the generator is very very slow at first, but the difference provided by materials is
 * 	incredibly massive, in which you gain N RF when you receive the "Package"
 * 
 * Generates a random # of enderman attacks before they get fed up with the packet and send it back
 * these attacks are based on mass, pearls and shield. They are less likely to attack shielded mass because it hides
 * the presence of the packet, but ender pearls tend to attract them.
 * 
 * Ender pearls provide the "Umph", some are used if the enderman do not respond to the pearls.
 * Any material provided, including dirt, stone, obsidian, ect. will act as the mass that is launched to and Fro.
 * 
 * Ender pearls are not lost unless the enderman manage to get their word in.
 * 
 * 1 ender pearl + 64 obsidian with no shields will not be very likely to attract the curious enderman's wrath, however,
 * 10 ender pearls + 1 stone will make them very angry when they realize they have had fallen brethren.
 * 
 * Shields will disguise the package's signature from the enderman by a degree, but they can still sense it enough to 
 * bring them over.
 * 
 * If the packet's Ender signature is too high, there is a chance that the ender dragon will catch the packet at the last
 * few kilometers of being received.
 * 
 * dirt = 1220 kg
 * CobbleStone = 2600 kg
 * Diamond Block = 3520 kg
 * Iron Block = 7870 kg
 * Gold Block = 19300 kg
 * Redstone Block = 1000 kg
 *  
 * 
 * The number of enderman here is put through an RNG God to help
 * 
 * Enderman Max = 5(P-1)^2+ 100*sqrt(x*g/10000)-1/33(S)^(1.3)-1000
 * 
 * With this equation, you can transport up to 211 gold blocks with no shield and 1 ender pearl.
 * 40.5 with 16 ender pearls
 * 
 * 
 * 
 * Power = const*mass*velocity
 * Velocity = const2*Pearls*Acceleration
 * 
 * 
 * Acceleration Ballistic Arc:
 * Trajectory Height = H = 2000
 * Distance = D = 2000
 * Ender pearls = E = 10
 * 
 * Slow Factor = S = 10000*(20 TPS)
 * 
 * -(E/(S*D))*(x-D/2)^3
 * 
 * 10 Ender pearls = initial 500 m/s^2
 * m/s^2 per tick = 25
 */



public class TileEntityEnderPongReactor  extends TileEntity implements IInventory {
	private static Thread EPRThread;
	private static LinkedList<TileEntityEnderPongReactor> entities = new LinkedList<TileEntityEnderPongReactor>();
	private int enderPearls = 0; // Number of loaded Ender Pearls
	private LargeContainer temporary = new LargeContainer(); // Number of loaded Ender Pearls
	private LinkedList<EnderPongPacket> packets = new LinkedList<EnderPongPacket>();
	
	private double Power;
	private ItemStack[] inv;
	
	public TileEntityEnderPongReactor(){
		super();
		
		if(FMLCommonHandler.instance().getEffectiveSide() == Side.SERVER){
			if(EPRThread == null){
				Runnable runner = new Runnable(){
				     public void run(){
				    	 EnderPongThread();
				     }
				};
				
				EPRThread = new Thread(runner);
				EPRThread.setName("EternalPower EnderPongReactors Thread");
				EPRThread.start();
			}
			
			entities.add(this);
			
			this.Power = 0;
		}
	}
	
	
	
	
	
	public void updateEntity(){
		//if(!this.worldObj.canBlockSeeTheSky(this.getPos().getX(),this.getPos().getY(),this.getPos().getZ())) return;
	}
	
	// loop through each packet, or launch packets after their shields are charged
	public void processReactor(){
		ListIterator<EnderPongPacket> iterator = packets.listIterator();
		
		while(iterator.hasNext()){
			EnderPongPacket packet = iterator.next();
			
			Power = packet.processPacket(Power);
		}
	}
	
	//@SideOnly(Side.SERVER)
	public static void EnderPongThread(){
		// Make sure that the server is still running for this, else exit
		while(MinecraftServer.getServer().isServerRunning()){
			try{
				ListIterator<TileEntityEnderPongReactor> iterator = entities.listIterator();
				
				while(iterator.hasNext()){
					TileEntityEnderPongReactor reactor = iterator.next();
					reactor.processReactor();
				}
				
				
			}catch(Exception e){
				EternalPower.getInstance().getLogger().severe("EnderPongReactor Thread Error: "+e.getMessage());
				e.printStackTrace();
			}
			
			// Enforce 10 TPS
			try { Thread.sleep(100); } catch (InterruptedException e) {}
		}
	}


	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return null;
	}





	@Override
	public boolean hasCustomName() {
		// TODO Auto-generated method stub
		return false;
	}





	@Override
	public IChatComponent getDisplayName() {
		// TODO Auto-generated method stub
		return null;
	}





	@Override
	public ItemStack removeStackFromSlot(int index) {
		// TODO Auto-generated method stub
		return null;
	}





	@Override
	public void openInventory(EntityPlayer player) {
		// TODO Auto-generated method stub
		
	}





	@Override
	public void closeInventory(EntityPlayer player) {
		// TODO Auto-generated method stub
		
	}




	@Override
	public int getField(int id) {
		// TODO Auto-generated method stub
		return 0;
	}





	@Override
	public void setField(int id, int value) {
		// TODO Auto-generated method stub
		
	}





	@Override
	public int getFieldCount() {
		// TODO Auto-generated method stub
		return 0;
	}





	@Override
	public void clear() {
		// TODO Auto-generated method stub
		
	}
	
	
	 @Override
     public int getSizeInventory() {
             return inv.length;
     }

     @Override
     public ItemStack getStackInSlot(int slot) {
             return inv[slot];
     }

     @Override
     public void setInventorySlotContents(int slot, ItemStack stack) {
             inv[slot] = stack;
             if (stack != null && stack.stackSize > getInventoryStackLimit()) {
                     stack.stackSize = getInventoryStackLimit();
             }
     }

     @Override
     public ItemStack decrStackSize(int slot, int amt) {
             ItemStack stack = getStackInSlot(slot);
             if (stack != null) {
                     if (stack.stackSize <= amt) {
                             setInventorySlotContents(slot, null);
                     } else {
                             stack = stack.splitStack(amt);
                             if (stack.stackSize == 0) {
                                     setInventorySlotContents(slot, null);
                             }
                     }
             }
             return stack;
     }

     @Override
     public int getInventoryStackLimit() {
             return 1000000;
     }

     @Override
 	public boolean isUseableByPlayer(EntityPlayer player){
 		return this.worldObj.getTileEntity(this.getPos())!=this ? false : player.getDistanceSq(this.getPos().getX()+0.5D,this.getPos().getY()+0.5D,this.getPos().getZ()+0.5D)<=64.0D;
 	}

     @Override
     public void readFromNBT(NBTTagCompound tagCompound) {
             super.readFromNBT(tagCompound);

             NBTTagList tagList = tagCompound.getTagList("Inventory", 10);
             for (int i = 0; i < tagList.tagCount(); i++) {
                     NBTTagCompound tag = (NBTTagCompound) tagList.getCompoundTagAt(i);
                     byte slot = tag.getByte("Slot");
                     if (slot >= 0 && slot < inv.length) {
                             inv[slot] = ItemStack.loadItemStackFromNBT(tag);
                     }
             }
     }

     @Override
     public void writeToNBT(NBTTagCompound tagCompound) {
             super.writeToNBT(tagCompound);

             NBTTagList itemList = new NBTTagList();
             for (int i = 0; i < inv.length; i++) {
                     ItemStack stack = inv[i];
                     if (stack != null) {
                             NBTTagCompound tag = new NBTTagCompound();
                             tag.setByte("Slot", (byte) i);
                             stack.writeToNBT(tag);
                             itemList.appendTag(tag);
                     }
             }
             tagCompound.setTag("Inventory", itemList);
     }

     @Override
     public boolean isItemValidForSlot(int slot, ItemStack itemStack) {
             return true;
     }
}


